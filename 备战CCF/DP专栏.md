# DP问题

## 背包问题

### 01背包问题

常见模板：N件物品以及V容量的背包，**每个物品只能塞入一次**，求装入背包的最大价值。

```C++
//二维01背包
//f[i][j]定义：在前i件物品中以及容量为j的情况下的最大价值
for (int i = 1; i <= n; i ++ )
{
    for (int j = 1; j <= m; j ++ )
    {
        //首先是不取（或者容积不够）第i件物品的情况，此时与之前情况一样
        f[i][j] = f[i - 1][j];
        //当背包的容积 > 第j件物品的体积时选择可取
        if (j >= v[i])
            //f[i - 1][j - v[i]] + w[i]是指在取走第i件物品后，则将问题转化至前i - 1件物品j - v[i]容积的情况，然后加上i的价值w[i]。
            f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
    }
}
//最终答案则为f[N][V];
//二维可以边输入边处理，增加空间效率


//一维01背包
//f[i]定义：容积为i的情况下的最大价值
for(int i = 1; i <= n; i++)
{
    for(int j = m; j >= v[i]; j--)  
        f[j] = max(f[j], f[j - v[i]] + w[i]);
        //第二维为逆序是关键步骤，由于在二维背包中的状态转移方程全部如下
        //f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);
        //在该转移方程中f[i][j]的状态与i - 1无关，这也是要省略第一维的关键
        //逆序则是要使用第i - 1轮的状态
        //则若第二维还是顺序的话，则f[j - v[i]]的状态就会被更新
        //eg: 若顺序的话，f[4]会先于f[7]更新
        //到f[7] = f[7 - 3] + w[i]时，此时f[4]是第i轮的状态，则是错误的状态
        //逆序情况下:到f[7] = f[7 - 3] + w[i]时，此时f[4]仍未更新，还是第i - 1轮状态
}

//对于一维背包的进一步优化
for(int i = 1; i <= n; i++) {
    int v, w;
    cin >> v >> w;      // 边输入边处理，可以省略存储空间，提升效率
    for(int j = m; j >= v; j--)
        f[j] = max(f[j], f[j - v] + w);
}
```



### 完全背包问题

常见模板：N件物品以及V容量的背包，**每个物品不限塞入次数**，求装入背包的最大价值。

```C++
//二维模板：
for (int i = 1; i <= n; i ++ )
{
    for (int j = 1; j <= m; j ++ )
    {
        f[i][j] = f[i - 1][j];
        if (j >= v[i])
            f[i][j] = max(f[i - 1][j], f[i][j - v[i]] + w[i]);
    }
}

//状态转移方程的推导过程
f[i][j] = max(f[i-1][j], f[i-1][j-v]+w, f[i-1][j-2*v]+2*w, f[i-1][j-3*v]+3*w, ......);
f[i][j-v] = max(f[i-1][j-v], f[i-1][j-2*v]+w, f[i-1][j-3*v]+2*w, ......);
//将2式统一+w后带入1式得
f[i][j] = max(f[i - 1][j], f[i][j - v] + w);

//完全背包问题的一维优化
for(int i = 1 ; i<=n ;i++)
{
    for(int j = v[i] ; j<=m ;j++)
    //注意了，这里的j是从小到大枚举，经过公式推导后刚好和01背包不一样
    {
        f[j] = max(f[j],f[j-v[i]]+w[i]);
        //此时举例
        //f[7] = f[7 - 3] + w;
        //此时的f[4]正好是第i轮的结果
        //若f[7] = f[7]
        //此时就是等于第i - 1轮的结果
    }
}
```



### 多重背包问题

常见模板：N件物品以及V容量的背包，**第i种物品有Si件**，求装入背包的最大价值。

```C++
//思路拓展：若多重背包的物品总数较少的话，可以将其转换为01背包去做


//基础二维版本
//f[i][j]定义：j容积下前i个物品的最大价值
for(int i = 1; i <= n; i ++)
{//枚举背包
    for(int j = 1; j <= m; j ++)
    {//枚举体积
        for(int k = 0; k <= s[i]; k ++){
            //由于此时k从0开始遍历，所以默认包含了f[i - 1][j]的情况
            //若第i个物品选k个比选k-1个要大，就会更新f[i][j]
            //但该情况先写在前面会出错，原因是每次将第i个物品取0个和取k个进行比较，就会逻辑错误
            if(j >=  k * v[i]){
                f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);
            } 
        }
    }
}

//一维优化
for(int i = 1; i <= n; ++i)
    for(int j = m; j>=0; --j)   
        for(int k = 1; k <= s[i]; ++k) 
            if(j >= k*w[i])
                f[j] = max(f[j], f[j-k*w[i]]+k*v[i]);

//读入优化
for (int i = 0; i < n; i ++ )
{
    int v, w, s;
    cin >> v >> w >> s;
    for (int j = m; j >= 0; j -- )
        for (int k = 1; k <= s && k * v <= j; k ++ )
            f[j] = max(f[j], f[j - k * v] + k * w);
}

//上述方法存在的问题：时间复杂度过高（O(n3)），需要使用二进制优化
//优化代码
for (int i = 0; i < n; i ++ )
{
    int v, w, s;
    cin >> v >> w >> s;
    for (int j = 1; j <= s; j *= 2)
    //按照二进制的方法优化变为01背包模型
    {
        s -= j;
        goods.push_back({v * j, w * j});
    }
    if (s > 0 ) goods.push_back({v * s, w * s});
}
```



### 分组背包问题

常见模板：N组物品以及V容量的背包，**每组物品有若干件，同一组内的物品最多只能选一个**，求装入背包的最大价值。

```C++
//二维代码
for(int i=1;i<=n;i++){
    for(int j=0;j<=m;j++){
        f[i][j]=f[i-1][j];  //不选
        for(int k=0;k<s[i];k++)	//每个组的物品列举
        {	
            if(j>=v[i][k])     
                f[i][j]=max(f[i][j],f[i-1][j-v[i][k]]+w[i][k]);  
        }
    }
}


//一维优化
for (int i = 0; i < n; i ++ )
{
    int x;
    cin >> x;	//每组的数量
    for (int j = 0; j < x; j ++ )   cin >> v[j] >> w[j];	//占用容积和价值
    for (int j = m; j >= 0; j -- )	//同样使用逆序要保证其使用第i - 1轮的状态
        for (int k = 0; k < x; k ++ )	//枚举该组种的物品
            if (v[k] <= j)  
                f[j] = max(f[j], f[j - v[k]] + w[k]);
}
```



## 线性DP

### 最长上升子序列

**最长上升子序列LIS（longest increasing subsequence）**

常见模板：给定一个长度为 NN 的数列，求数值严格单调递增的子序列的长度最长是多少。

```C++
//模板代码
for (int i = 1; i <= n; i ++ )
{
    f[i] = 1;
    for (int j = 1; j < i; j ++ )
        if (w[i] > w[j])    f[i] = max(f[i], f[j] + 1);
    ans = max(ans, f[i]);
}

//上述代码存在的问题：时间复杂度过高（O(n2)），当数据范围到10^5的时候会产生TLE
//优化策略:使用降低代码的复杂度，时间复杂度为O(nlogn)
//将固定长度的子序列的最后一个最小值保存即可，使得严格保证re[0]<re[1]<re[2]<...<re[n];
//使用二分法返回小于当前值的最小的子序列最后一位值
for (int i = 0; i < n; i ++ )  
    cin >> a[i];
int len = 0;
re[0] = -2e9;	//re[i]即代表长度为i的最长子序列
for (int i = 0; i < n; i ++ )
{
    int l = 0, r = len;
    while (l < r)
    {
        //不能用>=的二分, 因为要找最大的小于a[i]的, 在最右侧才对
        int mid = (l + r + 1) >> 1;
        if (re[mid] < a[i])    l = mid;
        else    r = mid - 1;
    }
    re[r + 1] = a[i];
    len = max(r + 1, len);
}
```



### 最长公共子序列

**最长公共子序列LCS（longest common subsequence）**

常见模板：给定两个长度分别为 NN 和 MM 的字符串 AA 和 BB，求既是 AA 的子序列又是 BB 的子序列的字符串长度最长是多少。

```C++
//f[i][j]定义：第一个字符串的前i位和第二个字符串的前j位公共子串有多长
//样例代码：
for (int i = 1; i <= n; i ++ )
    for (int j = 1; j <= m ; j ++ )
    {
        //如果A串的第i个字符和B串的第j个字符不相等
        f[i][j] = max(f[i - 1][j], f[i][j - 1]);
        if (a[i] == b[j])   f[i][j] = f[i - 1][j - 1] + 1;
    }
cout << f[n][m];
```



## 区间DP

### 石子合并



























### 